# 1 算法参数与辅助函数
## 1.1 总则

密钥封装机制为用椭圆曲线对实现的基于标识的密钥封装机制。解封装用户持有一个标识和一个相应的加密私钥，该加密私钥由密钥生成中心通过加密主私钥和解封装用户的标识结合产生。

公钥加密算法为用椭圆曲线对实现的基于标识的公钥加密算法。该公钥加密算法是上述密钥封装机制和消息封装机制的结合，消息封装机制包括基于密钥派生函数的序列密码以及结合密钥派生函数的分组密码算法两种类型，该算法可提供消息的机密性。

## 1.2 系统加密主密钥和用户加密密钥的产生

KGC产生随机数ke作为加密主私钥，根据ke计算得到主公钥Pe，KGC秘密保存ke，公开Pe。

KGC选择并公开用一个字节表示的加密私钥生成函数识别符hid。

KGC根据用户的ID计算用户的加密私钥并告知用户。

## 1.3 辅助函数

### 1.3.1 密码杂凑函数 Hv()
密码杂凑函数Hv()的输出是长度恰为v比特的杂凑值。规定使用国家密码管理主管部门批准 的密码杂凑函数，如SM3密码杂凑算法。

### 1.3.2 密码函数 H1()
密码函数H1(Z, n)的输入为比特串Z和整数n，输出为一个整数h1∈[1, n-1]。 H1(Z, n)需要调用密码杂凑函数Hv()。

### 1.3.3 密码函数 H2()
密码函数H2(Z,n)的输入为比特串Z和整数n，输出为一个整数h2∈[1, n-1]。H2(Z, n)需要调用密码杂凑函数Hv()。

### 1.3.4 密钥派生函数
采用的密钥派生函数KDF()。

### 1.3.5 分组密码算法
使用国家密码管理主管部门批准的分组密码算法，如SM4分组密码算法。

### 1.3.6 消息认证码函数
消息认证码函数MAC(K2, Z)的作用是防止消息数据Z被非法篡改，它在密钥K2的控制下，产生消息数据比特串Z的认证码。在本基于标识的加密算法中，消息认证码函数使用密钥派生函数生成的密钥对密文比特串求取消息认证码，从而使解密者可以鉴别消息的来源和检验数据的完整性。消息认证码函数需要调用密码杂凑函数。

### 1.3.7 随机数发生器
使用国家密码管理主管部门批准的随机数发生器。

# 2 密钥封装机制及流程

## 2.1 密钥封装算法

为了封装比特长度为klen的密钥给用户B，作为封装者的用户A需要执行以下运算步骤:
~~~~
A1: 计算群G1中的元素QB=[H1(IDB||hid, N)]P1+Pe;
A2: 产生随机数r∈[1, N-1];
A3: 计算群G1中的元素 C=[r]QB，将C的数据类型转换为比特串;
A4: 计算群GT中的元素g=e(Pe, P2);
A5: 计算群GT中的元素 w=g^r，将w的数据类型转换为比特串; 
A6: 计算 K=KDF(C||w||IDB, klen)，若K为全0比特串，则返回A2。
A7: 输出(K, C)，其中 K 是被封装的密钥，C 是封装密文。
~~~~

## 2.2 密钥封装算法流程

## 2.3 解封装算法
用户B收到封装密文C后，为了对比特长度为klen的密钥解封装，需要执行以下运算步骤:
~~~~
B1: 验证C∈G1是否成立，若不成立则报错并退出;
B2: 计算群GT中的元素w’=e(C, deB)，将w’的数据类型转换为比特串;
B3: 将C的数据类型转换为比特串，计算封装的密钥 K’=KDF(C||w’||IDB, klen),若K’为全0比特串，则报错并退出;
B4: 输出密钥K’。
~~~~

## 2.4 解封装算法流程

# 3 公钥加密算法及流程
## 3.1 加密算法
设需要发送的消息为比特串M，mlen为M的比特长度，K1_len为分组密码算法中密钥K1的比特长度，K2_len为函数MAC(K2, Z)中密钥K2的比特长度。

为了加密明文 M 给用户 B，作为加密者的用户 A 应实现以下运算步骤:
~~~~
A1: 计算群G1中的元素QB=[H1(IDB||hid, N)]P1+Pe;
A2: 产生随机数r∈[1, N-1];
A3: 计算群G1中的元素C1=[r]QB，将C1的数据类型转换为比特串;
A4: 计算群GT中的元素g=e(Pe, P2);
A5: 计算群GT中的元素w=g^r，按将w的数据类型转换为比特串;
A6: 按加密明文的方法分类进行计算:
    a) 如果加密明文的方法是基于密钥派生函数的序列密码算法，则
        1) 计算整数 klen=mlen+K2_len，然后计算 K=KDF(C1||w||IDB, klen)。令K1为K最左边的mlen比特，K2为剩下的K2_len比特，若K1为全0比特串，则返回 A2;
        2) 计算 C2= M⊕K1。
    b) 如果加密明文的方法是结合密钥派生函数的分组密码算法，则
        1) 计算整数klen=K1_len+K2_len，然后计算K=KDF(C1||w||IDB, klen)。令K1为K最左边的K1_len比特，K2为剩下的K2_len比特，若K1为全0比特串，则返回A2;
        2) 计算C2=Enc(K1, M)。
A7: 计算 C3=MAC(K2, C2);
A8: 输出密文 C=C1||C3||C2。
~~~~

## 3.2 加密算法流程

## 3.3 解密算法
设mlen为密文C=C1||C3||C2中C2的比特长度，K1_len为分组密码算法中密钥K1的比特长度，K2_len为函数MAC(K2, Z)中密钥K2的比特长度。

为了对 C 进行解密，作为解密者的用户 B 应实现以下运算步骤:
~~~~
B1: 从C中取出比特串C1，将C1的数据类型转换为椭圆曲线上的点，验证 C1∈G1是否成立，若不成立则报错并退出;
B2: 计算群T中的元素w’=e(C1, deB)，将 w’的数据类型转换为比特串;
B3: 按加密明文的方法分类进行计算:
    a) 如果加密明文的方法是基于密钥派生函数的序列密码算法，则
        1) 计算整数 klen=mlen+K2_len，然后计算 K’=KDF(C1||w’||IDB, klen)。令 K1’为 K’最左边的mlen比特，K2’为剩下的K2_len比特，若K1’为全0比特串，则报错并退出;
        2) 计算 M’=C2⊕K1’。
    b) 如果加密明文的方法是结合密钥派生函数的分组密码算法，则
        1) 计算整数 klen=K1_len+K2_len，然后计算 K’=KDF(C1||w’||IDB, klen)。令 K1’为K’最左边的K1_len比特，K2’为剩下的K2_len比特，若 K1’为全0比特串，则报错并退出;
        2) 计算 M’=Dec(K1’, C2)。
B4: 计算u=MAC(K2’, C2)，从C中取出比特串C3，若u∈C3，则报错并退出;
B5: 输出明文M’。
~~~~

## 3.4 解密算法流程
